# =============================================================================
# RSA暗号を理解する
#
# RSA = Rivest, Shamir, Adleman（発明者3人の頭文字）
# 1977年にMITで発表。2002年にチューリング賞受賞。
#
# 「鍵を公開しても安全」という不思議な暗号方式。
# 素因数分解の難しさを利用しています。
# =============================================================================

puts "=== RSA暗号の核心 ==="
puts

puts <<~TEXT
対称鍵暗号（XOR暗号、AESなど）の問題:
  → 暗号化と復号に「同じ鍵」を使う
  → その鍵をどうやって安全に共有する？（鍵配送問題）

RSAの解決策:
  → 「公開鍵」と「秘密鍵」の2つを使う
  → 公開鍵は誰に見られてもOK（だから「公開」）
  → 公開鍵で暗号化 → 秘密鍵でしか復号できない
TEXT
puts

# =============================================================================
puts "=== ステップ1: 数学の準備（mod演算） ==="
puts

# -----------------------------------------------------------------------------
# mod（剰余演算）の復習
#
# a mod n = a を n で割った余り
#
# RSAではこの「余りの世界」で計算する
# → どんなに大きな数も、一定の範囲に収まる
# -----------------------------------------------------------------------------

puts "mod演算の例:"
puts "  17 mod 5 = #{17 % 5}  （17÷5=3余り2）"
puts "  100 mod 7 = #{100 % 7}  （100÷7=14余り2）"
puts

puts "累乗のmod:"
puts "  2^10 = #{2**10}"
puts "  2^10 mod 100 = #{(2**10) % 100}  （大きな数も小さくなる）"
puts

# =============================================================================
puts "=== ステップ2: RSAの鍵生成（超シンプル版） ==="
puts

# -----------------------------------------------------------------------------
# RSA鍵生成の手順
#
# 1. 2つの素数 p, q を選ぶ
# 2. n = p × q を計算（これが「鍵のサイズ」）
# 3. φ(n) = (p-1)(q-1) を計算（オイラーのトーシェント関数）
# 4. e を選ぶ（φ(n)と互いに素な数、通常65537）
# 5. d を計算（e × d ≡ 1 mod φ(n) となる数）
#
# 公開鍵: (e, n)
# 秘密鍵: (d, n)
# -----------------------------------------------------------------------------

# 小さな素数で実験（実際は数百桁の素数を使う）
p_prime = 61
q_prime = 53

# n = p × q
n = p_prime * q_prime
puts "1. 素数を選ぶ: p=#{p_prime}, q=#{q_prime}"
puts "2. n = p × q = #{n}"

# φ(n) = (p-1)(q-1)
phi_n = (p_prime - 1) * (q_prime - 1)
puts "3. φ(n) = (p-1)(q-1) = #{phi_n}"

# e: 公開指数（φ(n)と互いに素な数）
e = 17  # 小さい例。実際は65537がよく使われる
puts "4. e = #{e}（公開指数）"

# d: 秘密指数（e × d ≡ 1 mod φ(n)）
# 拡張ユークリッドの互除法で求める
#
# なぜこの方法？
#   e × d ≡ 1 (mod φ) は「eの逆元dを求める」問題
#   → ax + by = gcd(a,b) の形に帰着できる（ベズーの等式）
#   → 拡張ユークリッド互除法で x, y が求まる
def mod_inverse(e, phi)
  # 拡張ユークリッドの互除法
  # gcd(a, b) を求めると同時に、ax + by = gcd(a,b) の x, y も求める
  #
  # 再帰の動き（例: gcd(17, 3120)）:
  #   gcd(17, 3120) → gcd(3120 % 17, 17) → gcd(8, 17) → ...
  #   戻りながら x, y を計算していく
  def extended_gcd(a, b)
    # ベースケース: a=0 なら gcd=b, x=0, y=1
    return [b, 0, 1] if a == 0

    # 再帰: 小さい問題を先に解く
    gcd, x1, y1 = extended_gcd(b % a, a)

    # 戻りながら x, y を計算
    # b = (b/a)*a + (b%a) の関係を使って係数を更新
    x = y1 - (b / a) * x1
    y = x1
    [gcd, x, y]
  end

  _, x, _ = extended_gcd(e % phi, phi)
  # xが負になる場合があるので、正の値に調整
  (x % phi + phi) % phi
end

d = mod_inverse(e, phi_n)
puts "5. d = #{d}（秘密指数）"
puts

puts "=== 鍵ペア完成 ==="
puts "  公開鍵: (e=#{e}, n=#{n})  ← 誰にでも公開OK"
puts "  秘密鍵: (d=#{d}, n=#{n})  ← 絶対秘密！"
puts

# =============================================================================
puts "=== ステップ3: 暗号化と復号 ==="
puts

# -----------------------------------------------------------------------------
# RSAの暗号化・復号
#
# 暗号化: c = m^e mod n  （mは平文、cは暗号文）
# 復号:   m = c^d mod n
#
# なぜこれで元に戻る？
# → フェルマーの小定理とオイラーの定理による
# → m^(e×d) ≡ m (mod n) が成り立つ
# -----------------------------------------------------------------------------

# 平文（数値として扱う。実際は文字をバイト列→数値に変換）
message = 42
puts "平文: m = #{message}"

# 暗号化: c = m^e mod n
# 大きな累乗を効率的に計算（繰り返し二乗法 / バイナリ法）
#
# なぜ必要？
#   42^2753 を普通に計算すると天文学的に大きな数になる
#   繰り返し二乗法なら O(log n) 回の乗算で済む
#
# アイデア:
#   指数を2進数で考える。例: 13 = 1101(2) = 8+4+1
#   x^13 = x^8 × x^4 × x^1
#   x^1, x^2, x^4, x^8... は順に2乗していけば求まる
def mod_pow(base, exp, mod)
  result = 1
  base = base % mod

  while exp > 0
    # 指数の最下位ビットが1なら、その桁の値を結果に掛ける
    if exp.odd?
      result = (result * base) % mod
    end
    # 指数を右シフト（÷2）、底を2乗
    exp = exp >> 1
    base = (base * base) % mod
  end
  result
end

ciphertext = mod_pow(message, e, n)
puts "暗号化: c = m^e mod n = #{message}^#{e} mod #{n} = #{ciphertext}"

# 復号: m = c^d mod n
decrypted = mod_pow(ciphertext, d, n)
puts "復号:   m = c^d mod n = #{ciphertext}^#{d} mod #{n} = #{decrypted}"
puts
puts "元に戻った！"
puts

# =============================================================================
puts "=== ステップ4: なぜ公開鍵を公開しても安全？ ==="
puts

puts <<~TEXT
攻撃者が知っているもの:
  - 公開鍵 (e=#{e}, n=#{n})
  - 暗号文 c=#{ciphertext}

秘密鍵 d を求めるには:
  1. n を素因数分解して p, q を得る
  2. φ(n) = (p-1)(q-1) を計算
  3. d を計算

問題: n=#{n} の素因数分解は？
TEXT
puts

puts "n=#{n} は小さいのですぐ分かる: #{p_prime} × #{q_prime}"
puts
puts "でも実際のRSAでは..."
puts "  n = 2048ビット（617桁）の数"
puts "  素因数分解に宇宙の寿命以上かかる"
puts
puts "→ 素因数分解の難しさがRSAの安全性の根拠！"
puts

# =============================================================================
puts "=== ステップ5: 文字列を暗号化してみる ==="
puts

# -----------------------------------------------------------------------------
# 実際の使い方
#
# 文字 → ASCII値 → RSA暗号化 → 暗号文
# （本来は文字列をブロック化してもっと複雑な処理をする）
# -----------------------------------------------------------------------------

# 文字列をRSA暗号化
# 各文字のASCII値を個別に暗号化する（簡易版）
# 注意: 実際のRSAでは文字列をブロック化してパディングを追加する
def rsa_encrypt_string(text, e, n)
  text.bytes.map { |b| mod_pow(b, e, n) }
end

# RSA暗号文を復号して文字列に戻す
def rsa_decrypt_string(encrypted, d, n)
  encrypted.map { |c| mod_pow(c, d, n).chr }.join
end

original = "Hi!"
puts "平文: #{original}"

encrypted = rsa_encrypt_string(original, e, n)
puts "暗号化: #{encrypted}"

decrypted = rsa_decrypt_string(encrypted, d, n)
puts "復号: #{decrypted}"
puts

# =============================================================================
puts "=== ステップ6: デジタル署名（おまけ） ==="
puts

# -----------------------------------------------------------------------------
# RSAは「逆向き」にも使える！
#
# 通常:   公開鍵で暗号化 → 秘密鍵で復号
# 署名:   秘密鍵で署名   → 公開鍵で検証
#
# 「秘密鍵を持っている人だけが作れる」署名になる
# -----------------------------------------------------------------------------

puts <<~TEXT
通常の暗号化:
  送信者: 相手の公開鍵で暗号化
  受信者: 自分の秘密鍵で復号

デジタル署名:
  署名者: 自分の秘密鍵でハッシュを「暗号化」
  検証者: 署名者の公開鍵で「復号」してハッシュと比較

RSAの面白い性質:
  - (m^d)^e mod n = m  （秘密鍵→公開鍵でも元に戻る）
  - だから暗号と署名の両方に使える！
TEXT
puts

# 署名のデモ
message_to_sign = 123  # 本来はメッセージのハッシュ値
signature = mod_pow(message_to_sign, d, n)  # 秘密鍵で署名
verified = mod_pow(signature, e, n)          # 公開鍵で検証

puts "--- 署名のデモ ---"
puts "メッセージ（ハッシュ値）: #{message_to_sign}"
puts "署名 = m^d mod n = #{signature}"
puts "検証 = 署名^e mod n = #{verified}"
puts "一致？ #{verified == message_to_sign ? 'OK！本人の署名です' : 'NG'}"
puts

# =============================================================================
puts "=== まとめ ==="
puts

puts <<~TEXT
RSAのポイント:
  1. 公開鍵と秘密鍵のペア
  2. 公開鍵で暗号化 → 秘密鍵でしか復号できない
  3. 素因数分解の難しさが安全性の根拠
  4. 逆向きに使えば「デジタル署名」

実際の使われ方:
  - RSAは計算が重い（遅い）
  - なので「AESの鍵」をRSAで暗号化して送る
  - 本体のデータはAESで暗号化（ハイブリッド暗号）

これがHTTPS（SSL/TLS）の基本的な仕組み！
TEXT
