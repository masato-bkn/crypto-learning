# =============================================================================
# ハッシュ関数を理解する（超シンプル版から）
#
# このファイルでは、ハッシュ関数の基本的な仕組みを段階的に学びます。
# ステップ1〜4で徐々に複雑にしていき、最後にSHA-256の概念を説明します。
# =============================================================================

puts "=== ステップ1: 世界一シンプルなハッシュ ==="
puts

# -----------------------------------------------------------------------------
# 最も単純なハッシュ: 文字コードを全部足すだけ
#
# 仕組み:
#   "abc" → 97 + 98 + 99 = 294 → 294 % 256 = 38
#
# 問題点:
#   順番を無視するので "abc" と "cba" が同じ値になってしまう（衝突）
# -----------------------------------------------------------------------------
def super_simple_hash(text)
  total = 0
  text.each_char do |c|
    # ord: 文字をASCIIコード（数値）に変換
    # 例: 'a'.ord => 97, 'b'.ord => 98
    total += c.ord
  end
  # % 256: 剰余演算で0〜255の範囲に収める
  # なぜ256? → 8ビット（1バイト）で表現できる最大値+1
  total % 256
end

["hello", "world", "abc", "cba"].each do |word|
  puts "#{word} → #{super_simple_hash(word)}"
end

puts
puts "問題点: 'abc'と'cba'が同じ値になる（順番が無視される）"
puts

# =============================================================================
puts "=== ステップ2: 順番も考慮する ==="
puts

# -----------------------------------------------------------------------------
# 改良版: 文字の位置で重み付けする
#
# 仕組み:
#   "abc" → 97×1 + 98×2 + 99×3 = 97 + 196 + 297 = 590 → 590 % 256 = 78
#   "cba" → 99×1 + 98×2 + 97×3 = 99 + 196 + 291 = 586 → 586 % 256 = 74
#
# 改善点: 順番が違えば違う値になる
# 問題点: まだ予測しやすい（線形な計算だから）
# -----------------------------------------------------------------------------
def better_hash(text)
  total = 0
  text.each_char.with_index do |c, i|
    # (i + 1) を掛けることで位置情報を含める
    # i=0から始まるので+1している（0を掛けると消えてしまうため）
    total += c.ord * (i + 1)
  end
  total % 256
end

["abc", "cba", "hello", "olleh"].each do |word|
  puts "#{word} → #{better_hash(word)}"
end

puts
puts "これでも弱い。本物はもっと「混ぜる」"
puts

# =============================================================================
puts "=== ステップ3: XORで混ぜる ==="
puts

# -----------------------------------------------------------------------------
# XOR（排他的論理和）の説明
#
# XORの特徴:
#   - 同じビット同士 → 0
#   - 違うビット同士 → 1
#
# なぜハッシュで使う?
#   - 情報を「混ぜる」のに最適
#   - A XOR B XOR B = A（元に戻せる性質、暗号で重要）
#   - 偏りが少ない（0と1が均等に出やすい）
# -----------------------------------------------------------------------------
puts "XORとは？"
puts "0 XOR 0 = 0"
puts "0 XOR 1 = 1"
puts "1 XOR 0 = 1"
puts "1 XOR 1 = 0  ← 同じだと0になる"
puts
puts "例: 5 XOR 3"
puts "  5 = 0101"
puts "  3 = 0011"
puts "  --------"
puts "      0110 = 6"
puts
puts "Rubyでは: 5 ^ 3 = #{5 ^ 3}"
puts

# -----------------------------------------------------------------------------
# XORだけのハッシュ
#
# 仕組み: 各文字のコードを順番にXORしていく
#
# 問題点:
#   - XORは順番に依存しない（A XOR B = B XOR A）
#   - だから "hello" と "olleh" で同じ値になりうる
# -----------------------------------------------------------------------------
def xor_hash(text)
  result = 0
  text.each_char do |c|
    # ^ はRubyのXOR演算子
    result = result ^ c.ord
  end
  result
end

["hello", "world"].each do |word|
  puts "#{word} → #{xor_hash(word)}"
end
puts

# =============================================================================
puts "=== ステップ4: ビットシフトで更に混ぜる ==="
puts

# -----------------------------------------------------------------------------
# ビットシフトの説明
#
# << 左シフト: ビットを左にずらす（×2のn乗と同じ）
# >> 右シフト: ビットを右にずらす（÷2のn乗と同じ）
#
# なぜハッシュで使う?
#   - ビットの位置を変えることで、より複雑に混ぜられる
#   - 高速（CPUが直接サポートしている演算）
# -----------------------------------------------------------------------------
puts "ビットシフトとは？"
puts "5 = 00000101"
puts "5 << 2（左に2シフト）= 00010100 = 20"
puts "5 >> 1（右に1シフト）= 00000010 = 2"
puts
puts "Ruby: 5 << 2 = #{5 << 2}, 5 >> 1 = #{5 >> 1}"
puts

# -----------------------------------------------------------------------------
# シフト + XOR を組み合わせたハッシュ
#
# 仕組み:
#   1. result を左に5ビットシフト（古い値を「ずらす」）
#   2. 新しい文字コードをXOR（新しい値を「混ぜる」）
#   3. result を右に3ビットシフトしたものもXOR（更に複雑に）
#   4. & 0xFF で8ビットに収める
#
# 効果: 「雪崩効果」が生まれる
#   → 入力が1ビット変わると、出力が大きく変わる
#   → これがハッシュ関数の重要な性質
# -----------------------------------------------------------------------------
def shift_hash(text)
  result = 0
  text.each_char do |c|
    # 複数の演算を組み合わせて「混ぜる」
    # result << 5 : 過去の計算結果を左にずらす
    # c.ord       : 新しい文字を混ぜる
    # result >> 3 : 過去の結果の一部を再度混ぜる（フィードバック）
    # & 0xFF      : 8ビット（0〜255）に収める（0xFF = 255 = 11111111）
    result = ((result << 5) ^ c.ord ^ (result >> 3)) & 0xFF
  end
  result
end

["hello", "hellp", "iello"].each do |word|  # 1文字違い
  puts "#{word} → #{shift_hash(word)}"
end
puts "→ 1文字違うだけで全然違う値になる！（雪崩効果）"
puts

# =============================================================================
puts "=== SHA-256がやっていること（概念） ==="
puts

# -----------------------------------------------------------------------------
# SHA-256の仕組み（概要）
#
# ステップ4でやったことの超強力版:
#   - 8ビットではなく256ビット（32バイト）を使う
#   - 1回ではなく64ラウンド繰り返す
#   - 6種類の複雑な関数で混ぜる
#
# 使われる演算:
#   - XOR（^）     : ビットを混ぜる
#   - AND（&）     : ビットを選択的に取り出す
#   - ローテート   : シフトだが、はみ出たビットが反対側に戻る
#   - 加算         : 更に複雑さを追加
#
# これにより:
#   - 入力が1ビット変わると出力の約半分のビットが変わる（雪崩効果）
#   - 出力から入力を逆算することが計算上不可能
# -----------------------------------------------------------------------------
puts <<~TEXT
1. メッセージを512ビットのブロックに分割
2. 各ブロックを64回「混ぜる」
3. 混ぜ方:
   - XOR（^）
   - AND（&）
   - ビットローテート（右に回す）
   - 加算

これを大量に繰り返すことで：
- 入力が1ビット変わると出力が完全に変わる
- 出力から入力を逆算できない
TEXT
